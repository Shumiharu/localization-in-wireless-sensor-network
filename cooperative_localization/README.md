# Cooperative Localization
nohup python launch.py config_0 &
nohup python launch.py config_0 > /dev/null 2>&1 &
nohup python launch.py config_0 > /dev/null 2> error.log &
## メモをここに残していきます
実際には測距できてないけど，推定座標位置からすると測距できる位置にいるので誤差が大きいと考えられるセンサノード -> VN
じゃあどうやって測距できる距離かサーバーが判定するの？
まず推定位置と測距できなかったセンサノードの距離を算出する
通信できる最大の距離を算出する．通信できる最大距離はどう算出するの？
山本先輩はパスロスモデルにいれて最大の距離を算出してるけどそれは違くないか？->サーバー側がパスロスモデルを知っていることになる（神様が存在）？
考えられるのは，送信電力と受信電力が既知であるから，その差（パスロス）から自由伝搬損失から求める
もしくは，得られた測距データのなかで最大のものを最大距離として考える．->一旦これで実装する．

sampleデータをとる際にANだけではなくTNのノードからのRSSIをとることで何か使えるのでは？

とおもったが，センサの配置間隔が短いせいもあり，想像以上にRSSIによるデータはあまり違いがないので難しいということがわかった．
測位して真ん中にあるもんから測位始めるのはありだが，経験則的な設定になってしまうのが懸念される

以上から
一旦全ての測距データを集める
で，LOPで初期解を算出できるものを絞り込んで，ANの中心に推定座標があるものから順番にモデルにかけていくのがベストだとわかった

外側のターゲットに関しては緩和法を用いると良いかも

11/02
新しいアルゴリズムで機械学習させると，凸包面積をはじめとして有意な特徴量を得ることが難しい
なので既存のアルゴリズムで学習させてから新しいアルゴリズムで測位を行う方が正解率の観点で考えたときに良いと言える
さらに陽性の条件を厳しくしても良いと思う
